{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { VNode, options } from \"preact\";\nimport { NativeTouchEvent } from \"react-native\";\n\nlet root: VNode;\n\nconst oldRootHook = (options as any)._root;\n\n(options as any)._root = (node: VNode) => {\n  root = node;\n\n  if (root != null) {\n    addEventListenerToDocument();\n  } else {\n    removeEventListenerToDocument();\n  }\n\n  if (oldRootHook) oldRootHook(node);\n};\n\nlet oldCommitHook = (options as any)._commit;\n\n(options as any)._commit = (node: VNode) => {\n  if (root && plugins.ResponderEventPlugin) {\n    const vnodes = [root];\n\n    while (vnodes.length) {\n      const vnode = vnodes.pop();\n\n      // it's a real vnode reflect to the dom\n      if (typeof (vnode as any).type === \"string\") {\n        (vnode as any)._dom._vnode = vnode;\n      }\n\n      if ((vnode as any)._children != null && (vnode as any)._children.length != null) {\n        for (let child of (vnode as any)._children) {\n          if (child != null) {\n            vnodes.push(child);\n          }\n        }\n      }\n    }\n  }\n\n  if (oldCommitHook) oldCommitHook(node);\n};\n\nenum ProcessType {\n  start = 0,\n  move,\n  end,\n}\nconst startResponderKey = \"onResponderStart\";\nconst moveResponderKey = \"onResponderMove\";\nconst endResponderKey = \"onResponderEnd\";\nconst startCheckerKeys = [\"onStartShouldSetResponderCapture\", \"onStartShouldSetResponder\"];\nconst moveCheckerKeys = [\"onMoveShouldSetResponderCapture\", \"onMoveShouldSetResponder\"];\nconst startDefinition = getEventDefinition(startCheckerKeys, startResponderKey, ProcessType.start);\nconst moveDefinition = getEventDefinition(moveCheckerKeys, moveResponderKey, ProcessType.move);\nconst endDefinition = getEventDefinition([], endResponderKey, ProcessType.end);\n\ninterface IDefinition {\n  checkerKeys: string[];\n  responderKey: string;\n  process: ProcessType;\n}\n\ninterface IResponderEvents {\n  [key: string]: IDefinition;\n}\n\nconst responderEvents: IResponderEvents = {\n  touchstart: startDefinition,\n  mousedown: startDefinition,\n  touchmove: moveDefinition,\n  mousemove: moveDefinition,\n  touchend: endDefinition,\n  mouseup: endDefinition,\n};\n\nfunction getEventDefinition(checkerKeys: string[], responderKey: string, process: ProcessType) {\n  return { checkerKeys, responderKey, process };\n}\n\nfunction addEventListenerToDocument() {\n  for (let event in responderEvents) {\n    document.addEventListener(event, eventListener);\n  }\n}\n\nfunction removeEventListenerToDocument() {\n  for (let event in responderEvents) {\n    document.removeEventListener(event, eventListener);\n  }\n}\n\nfunction getEventPath(e: IEvent) {\n  const path = [e.target];\n  const parent: any[] = [e.target];\n\n  while (parent.length) {\n    const ele = parent.pop();\n\n    if (ele.parentElement) {\n      parent.push(ele.parentElement);\n      path.push(ele.parentElement);\n    }\n  }\n\n  return path;\n}\n\ntype IChecker = (e: IEvent) => boolean;\n\ninterface ICheckers {\n  onMoveShouldSetResponderCapture?: IChecker;\n  onMoveShouldSetResponder?: IChecker;\n  onStartShouldSetResponderCapture?: IChecker;\n  onStartShouldSetResponder?: IChecker;\n}\n\ninterface IResponders {\n  onResponderStart?: (e: IEvent) => void;\n  onResponderMove?: (e: IEvent) => void;\n  onResponderEnd?: (e: IEvent) => void;\n}\n\ninterface IProcessors {\n  onResponderTerminationRequest?: IChecker;\n  onResponderTerminate?: (e: IEvent) => void;\n  onResponderGrant?: (e: IEvent) => void;\n  onResponderReject?: (e: IEvent) => void;\n  onResponderRelease?: (e: IEvent) => void;\n}\n\ntype IProps = ICheckers & IResponders & IProcessors;\n\ninterface ICheckerWrapper {\n  isCapture: boolean;\n  checker: IChecker;\n  props: IProps;\n  dom: HTMLElement;\n}\n\ninterface IEvent extends UIEvent {\n  nativeEvent: NativeTouchEvent;\n}\n\nfunction getCheckersWithPropsByEventPath(checkerKey: string, eventPath: HTMLElement[], isCapture: boolean) {\n  const checkers: ICheckerWrapper[] = [];\n\n  for (let dom of eventPath) {\n    const vnode = (dom as any)._vnode;\n\n    if (vnode != null) {\n      if (typeof vnode.props === \"object\") {\n        const checker = vnode.props[checkerKey];\n\n        if (checker != null) {\n          checkers.push({\n            isCapture,\n            checker,\n            props: vnode.props as IProps,\n            dom,\n          });\n        }\n      }\n    }\n  }\n\n  return checkers;\n}\n\nfunction getCheckers(eventType: string, eventPath: HTMLElement[], eventPathReverse: HTMLElement[]) {\n  const definition = responderEvents[eventType];\n  const checkerKeys = definition.checkerKeys;\n  const checkers: ICheckerWrapper[] = [];\n\n  for (let key of checkerKeys) {\n    // invoke capture checkers from root\n    if (key.indexOf(\"Capture\") > -1) {\n      checkers.push(...getCheckersWithPropsByEventPath(key, eventPathReverse, true));\n    } else {\n      checkers.push(...getCheckersWithPropsByEventPath(key, eventPath, false));\n    }\n  }\n\n  return checkers;\n}\n\nfunction getEventPaths(e: IEvent) {\n  const eventPath = (e as any).path || (e.composedPath != null ? e.composedPath() : getEventPath(e));\n  const eventPathReverse = eventPath.concat([]).reverse();\n  return { eventPath, eventPathReverse };\n}\n\nfunction setEvent(e: IEvent, responderKey: keyof IProps, props: IProps) {\n  const responder = props[responderKey];\n\n  if (plugins.ResponderEventPlugin!.view) {\n    plugins.ResponderEventPlugin!.view!.event = {\n      responder,\n      type: e.type,\n    };\n  }\n}\n\nfunction initView(e: IEvent, responderKey: keyof IProps, props: IProps, dom: HTMLElement) {\n  const responder = props[responderKey];\n\n  plugins.ResponderEventPlugin!.view = {\n    event: {\n      responder,\n      type: e.type,\n    },\n    props,\n    dom,\n  };\n\n  const { onResponderGrant } = props;\n\n  if (onResponderGrant) onResponderGrant(e);\n}\n\nfunction handleResponderTransferRequest(e: IEvent, definition: IDefinition, props: IProps, dom: HTMLElement) {\n  const view = getCurrentView();\n  // view can't be null here\n  const { onResponderTerminate, onResponderTerminationRequest } = view!.props;\n  const { onResponderReject } = props;\n\n  if (onResponderTerminationRequest) {\n    const allowTransfer = onResponderTerminationRequest(e);\n\n    if (allowTransfer) {\n      initView(e, definition.responderKey as keyof IProps, props, dom);\n      if (onResponderTerminate) onResponderTerminate(e);\n    } else {\n      if (onResponderReject) onResponderReject(e);\n    }\n  } else {\n    initView(e, definition.responderKey as keyof IProps, props, dom);\n    if (onResponderTerminate) onResponderTerminate(e);\n  }\n}\n\nfunction handleActiveTouches(e: IEvent) {\n  ResponderTouchHistoryStore.touchHistory.numberActiveTouches = e.nativeEvent.touches.length;\n}\n\nfunction isStartish(definition: IDefinition) {\n  return definition.process === ProcessType.start;\n}\n\nfunction isMoveish(definition: IDefinition) {\n  return definition.process === ProcessType.move;\n}\n\nfunction isEndish(definition: IDefinition) {\n  return definition.process === ProcessType.end;\n}\n\nfunction getCurrentView() {\n  if (plugins.ResponderEventPlugin) {\n    return plugins.ResponderEventPlugin.view;\n  }\n}\n\nfunction getCurrentEvent() {\n  const view = getCurrentView();\n  if (view) {\n    return view.event;\n  }\n}\n\nfunction getCurrentResponder() {\n  const event = getCurrentEvent();\n  if (event) {\n    return event.responder;\n  }\n}\n\nfunction executeResponder(e: IEvent, checker: ICheckerWrapper[]) {\n  const definition: IDefinition = responderEvents[e.type];\n\n  handleActiveTouches(e);\n\n  if (isStartish(definition) || isMoveish(definition)) {\n    for (let item of checker) {\n      e = { ...e, bubbles: !item.isCapture };\n\n      const requireToBeResponder = item.checker(e);\n\n      if (requireToBeResponder) {\n        const view = getCurrentView();\n\n        // if no responding view, set it and call granted\n        if (view == null) {\n          initView(e, definition.responderKey as keyof IProps, item.props, item.dom);\n        } else {\n          // if same view is responding, set new responder\n          if (view.dom === item.dom) {\n            setEvent(e, definition.responderKey as keyof IProps, item.props);\n          } else {\n            // if other view wants to response, start to negotiate\n            handleResponderTransferRequest(e, definition, item.props, item.dom);\n          }\n        }\n      }\n    }\n\n    const responder = getCurrentResponder();\n\n    if (responder) {\n      responder(e);\n      plugins.ResponderEventPlugin!.view!.event = null;\n    }\n  }\n\n  if (isEndish(definition)) {\n    const view = getCurrentView();\n\n    if (view != null) {\n      const { onResponderRelease, onResponderEnd } = view.props;\n\n      if (onResponderEnd) {\n        onResponderEnd(e);\n      }\n\n      if (ResponderTouchHistoryStore.touchHistory.numberActiveTouches === 0) {\n        if (onResponderRelease) {\n          onResponderRelease(e);\n        }\n\n        if (plugins.ResponderEventPlugin) {\n          plugins.ResponderEventPlugin.view = null;\n        }\n      }\n    }\n  }\n}\n\nfunction eventListener(e: Event) {\n  if (!plugins.ResponderEventPlugin) return;\n\n  const result = plugins.ResponderEventPlugin.extractEvents(e.type, {}, e, e.target as HTMLElement);\n\n  if (result == null) {\n    return;\n  }\n\n  const { nativeEvent } = result;\n\n  (e as IEvent).nativeEvent = nativeEvent;\n\n  const { eventPath, eventPathReverse } = getEventPaths(e as IEvent);\n  const checkers = getCheckers(e.type, eventPath as HTMLElement[], eventPathReverse as HTMLElement[]);\n\n  executeResponder(e as IEvent, checkers);\n}\n\ninterface IResponderEventPlugin {\n  view: {\n    dom: HTMLElement;\n    event: {\n      responder: ((e: IEvent) => void) | undefined;\n      type: string;\n    } | null;\n    props: IProps;\n  } | null;\n  extractEvents: (\n    eventType: string,\n    targetInst: IProps,\n    nativeEvent: Event,\n    nativeEventTarget: HTMLElement\n  ) => { nativeEvent: NativeTouchEvent };\n  eventTypes: any;\n}\n\nexport const ResponderEventPlugin: IResponderEventPlugin = {\n  view: null,\n  extractEvents: (eventType: string, props: IProps, nativeEvent: Event, nativeEventTarget: HTMLElement) => {\n    return {\n      // event will transform to NativeTouchEvent by react-native-web\n      nativeEvent: (nativeEvent as any) as NativeTouchEvent,\n    };\n  },\n  eventTypes: {\n    responderMove: {\n      dependencies: [\"touchmove\", \"mousemove\"],\n    },\n  },\n};\n\nexport const ResponderTouchHistoryStore = {\n  touchHistory: { numberActiveTouches: 0 },\n};\n\ninterface IPlugins {\n  ResponderEventPlugin?: IResponderEventPlugin;\n}\n\nlet plugins: IPlugins = {};\n\nexport const injectEventPluginsByName = (injectedPlugins: IPlugins) => {\n  plugins = Object.assign({}, plugins, injectedPlugins);\n};\n\nexport default {\n  injectEventPluginsByName,\n  ResponderEventPlugin,\n  ResponderTouchHistoryStore,\n};\n"],"names":["root","oldRootHook","oldCommitHook","ProcessType","moveCheckerKeys","startDefinition","moveDefinition","endDefinition","responderEvents","ResponderEventPlugin","ResponderTouchHistoryStore","plugins","injectEventPluginsByName","getEventDefinition","checkerKeys","responderKey","process","addEventListenerToDocument","let","event","document","addEventListener","eventListener","removeEventListenerToDocument","removeEventListener","getEventPath","e","ele","path","target","parent","length","pop","parentElement","push","getCheckersWithPropsByEventPath","checkerKey","eventPath","isCapture","dom","vnode","checker","checkers","_vnode","props","getCheckers","eventType","eventPathReverse","key","indexOf","getEventPaths","composedPath","concat","reverse","setEvent","view","type","initView","onResponderGrant","handleResponderTransferRequest","definition","getCurrentView","onResponderTerminationRequest","onResponderTerminate","onResponderReject","handleActiveTouches","touchHistory","numberActiveTouches","nativeEvent","touches","isStartish","start","isMoveish","move","isEndish","end","getCurrentEvent","getCurrentResponder","responder","executeResponder","item","Object","bubbles","onResponderEnd","onResponderRelease","result","extractEvents","options","_root","node","_commit","vnodes","child","_dom","_children","touchstart","mousedown","touchmove","mousemove","touchend","mouseup","injectedPlugins","assign","nativeEventTarget","eventTypes","responderMove","dependencies"],"mappings":"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"}